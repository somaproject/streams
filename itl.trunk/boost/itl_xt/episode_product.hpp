/*-----------------------------------------------------------------------------+    
Copyright (c) 2007-2009: Joachim Faulhaber
+------------------------------------------------------------------------------+
Copyright (c) 1999-2006: Cortex Software GmbH, Kantstrasse 57, Berlin
+------------------------------------------------------------------------------+
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
+-----------------------------------------------------------------------------*/
#ifndef BOOST_ITL_EPISODE_PRODUCT_HPP_HPP_JOFA_011005
#define BOOST_ITL_EPISODE_PRODUCT_HPP_HPP_JOFA_011005

#include <boost/itl/map.hpp>
#include <boost/itl_xt/episode_set.hpp>

namespace boost{namespace itl
{

/// A collection (product) of episodes of different types that do not change for a period of time
/**    
    <b>Eine Klasse zur Sammlung von Episoden unterschiedlichen Typs</b>

    episode_product ist so benannt nach dem mathematischen Ding
    (T1 e1, ... Tn en), was gelegentlich Produkt oder Tupel (in der Informatik
    auch struct (c), record (pascal)) genannt wird. Beim EpisodenProdukt
    sind Ti Typen und ei Episoden-Mengen. Die Elemente der Episodenmengen sind 
    vom Typ Ti. Implementiert wird das Ganze als Map

    { T1->e1, ... , Tn->en }. Es müssen also nicht alle Komponenten vorhanden sein.

    Template-Parameter <b>TimeT</b>: Domain-Typ der Episoden-Intervalle
    (z.B. Tage, Sekunden, Monate, int u.ä.). Episoden haben ja ein Intervall, das
    Anfang und Ende der Episode angibt.
  
    Template-Parameter <b>TypeDomain</b>: TypeDomain ist der Definitionsbereich (Domain)
    der Typen von Episoden, die in der Produkt-Historie verwendet werden können.
    
    Ein Episoden-Produkt ist ein Map (partielle Abbildung). Der Definitionbereich
    des Map ist ein Aufzählungstyp TypeDomain::DomainET. Das Map ist hierdurch auf ganz
    spezifische Werte und eine maximale Anzahl beschränkt.

    Der Wertebereich (CoDomain) sind Mengen von Episoden. Diese Episoden sind
    'getypte' \ref typed_episode, die ihren Typ kennen. Eine Episode aus einer 
    Episodenmenge ei
    hat immer den gleichen Typ aus TypeDomain::DomainET wie ihr Schlüssels Ti 
    eines Wertepaares (Ti, ei).

    Im Kontext von Produkthistorien repräsentieren die Episoden-Mengen die
    Episoden eines Typs, die sich überlappen. Eine einelementige Menge ist
    eine nichtüberlappende Episode eines Typs.


    Im Kontext von Produkthistorien kann man das EpisodenProdukt auch als
    <b>Episoden-Aufsammelobjekt für zeitliche Überlappung</b> betrachten:

    Eine Episodenmenge mit mehreren Elementen repräsentiert zeiliche Überlappung
    von Episoden gleichen Typs: Beispiel:

    { KUE -> { kueEpi_Bfa, kueEpi_Aok } }

    Episoden unterschiedlichen Typs repräsentieren Überlappung von Episoden
    unterschidlichen Typs: Beispiel:

    { AUFENTH -> {aufentEpi}, KUE -> {kueEpi} }
    

    @author  Joachim Faulhaber
*/

template <class TimeT, class TypeDomain>
class episode_product : public boost::itl::map<typename TypeDomain::DomainET, episode_set<TimeT,TypeDomain> >
{
public:
    typedef boost::itl::map<typename TypeDomain::DomainET, episode_set<TimeT,TypeDomain> > base_type;
    typedef    typename base_type::value_type value_type;
    typedef    typename base_type::data_type data_type;
    typedef    typename base_type::data_type EpisodeSetTD;
    typedef    typename episode_set<TimeT,TypeDomain>::value_type EpisodePTD;
    typedef typename base_type::iterator iterator;
    typedef typename base_type::const_iterator const_iterator;
    
public:

    /// Zu einem Episoden-Typ wird ein Pointer auf die erste Episode einer Episoden-Menge 
    ///    zurückgegeben. Wenn die Menge leer ist liefert die Funktion NULL.
    EpisodePTD getFirst(typename TypeDomain::DomainET type)const
    {
        const_iterator epiSet_ = find(type);
        if(epiSet_ == this->end()) 
            return NULL;
        else return *((*epiSet_).second.begin());
    }

    EpisodePTD getLast(typename TypeDomain::DomainET type)const
    {
        const_iterator epiSet_ = find(type);
        if(epiSet_ == this->end())
            return NULL;
        else return *((*epiSet_).second.rbegin());
    }

    EpisodeSetTD* getEpisodeSetPtr(typename TypeDomain::DomainET type)
    {
        iterator epiSet_ = find(type);
        if(epiSet_ == this->end()) 
            return NULL;
        else return &((*epiSet_).second);
    }
    
    int size(typename TypeDomain::DomainET type)const
    {
        const_iterator epiSet_ = find(type);
        if(epiSet_ == this->end()) 
            return 0;
        else return (*epiSet_).second.size();
    }
        
    bool insert(EpisodePTD pEpisode)
    {
        EpisodeSetTD sglSet;
        sglSet.insert(pEpisode);
        typename TypeDomain::DomainET type = pEpisode->type();
        return base_type::insert(value_type(type,sglSet)).second;
    }

    void leftAlignedEpisodes(episode_product& syncProd, const TimeT& start)
    {
        ITL_const_FORALL_THIS(elem_)
        {
            TypeDomain type = (*elem_).first;
            EpisodeSetTD& epiSet = (*elem_).first;
            
            EpisodeSetTD syncSet;
            ITL_const_FORALL(typename EpisodeSetTD, epi_, epiSet)
            {
                if((*epi_)->interval().first()==start)
                    syncSet.insert(*epi_);
            }
            syncProd.insert(episode_product::value_type(type, syncSet));
        }
    }
    

    std::string as_string()const
    {
        std::string str;
        const_iterator it = this->begin();

        if(it == this->end()) 
            return std::string("");
        else
        {
            std::string str( TypeDomain::as_string((*it).first) );
            str += ("{"+((*it).second).as_string()+"}");
            it++;
            
            while(it != this->end()) {
                str += ", "; str += TypeDomain::as_string((*it).first);
                str += ("{"+((*it).second).as_string()+"}");
                it++;
            }
            return str;
        }
    }

};


/* KEEP Eigentlich bessere Implementierung exemplarisch für 'using' in Verbindung
    private inheritence. Müsste aber wg. Rückwärtskompatibilität sorgfältig
    eingepflegt werden (eigentlich nur StatPflege)
NOTE MEMO DESIGN USING PRIVATE INHERITENCE

template <class TimeT, class TypeDomain>
class episode_product : private itl::MapT<TypeDomain::DomainET, episode_set<TimeT,TypeDomain> >
{
public:
    typedef itl::MapT<TypeDomain::DomainET, episode_set<TimeT,TypeDomain> > BaseTD;
    typedef BaseTD::value_type value_type;
    typedef BaseTD::data_type data_type;
    typedef BaseTD::data_type EpisodeSetTD;
    typedef episode_set<TimeT,TypeDomain>::value_type EpisodePTD;

    typedef BaseTD::iterator iterator;
    typedef BaseTD::const_iterator const_iterator;

public:

    using BaseTD::find;
    using BaseTD::begin;
    using BaseTD::end;

    using BaseTD::contains;

    episode_product& operator += (const episode_product& rhs) {    BaseTD::operator += (rhs); return *this; }
    episode_product& operator -= (const episode_product& rhs) {    BaseTD::operator -= (rhs); return *this; }

    /// Zu einem Episoden-Typ wird ein Pointer auf die erste Episode einer Episoden-Menge 
    ///    zurückgegeben. Wenn die Menge leer ist liefert die Funktion NULL.
    EpisodePTD getFirst(TypeDomain::DomainET type)const
    {
        const_iterator epiSet_ = find(type);
        if(epiSet_==end()) return NULL;
        else return *((*epiSet_).second.begin());
    }

    int size()const { return BaseTD::size(); }
    
    int size(TypeDomain::DomainET type)const
    {
        const_iterator epiSet_ = find(type);
        if(epiSet_==end()) return 0;
        else return (*epiSet_).second.size();
    }
    
    
    
    bool insert(EpisodePTD pEpisode)
    {
        EpisodeSetTD sglSet;
        sglSet.insert(pEpisode);
        TypeDomain::DomainET type = pEpisode->type();
        return BaseTD::insert(value_type(type,sglSet)).second;
    }

    std::string as_string()const
    {
        std::string str;
        const_iterator it = begin();

        if(it==end()) return std::string("");
        else
        {
            std::string str( TypeDomain::as_string((*it).first) );
            str += ("{"+((*it).second).as_string()+"}");
            it++;
            
            while(it != end()) {
                str += ", "; str += TypeDomain::as_string((*it).first);
                str += ("{"+((*it).second).as_string()+"}");
                it++;
            }
            return str;
        }
    }

};


template <class TimeT, class TypeDomain>
inline bool operator == (const episode_product<TimeT,TypeDomain>& lhs,
                         const episode_product<TimeT,TypeDomain>& rhs)
{
    if(lhs.size() != rhs.size())
        return false;

    episode_product<TimeT,TypeDomain>::const_iterator lhs_ = lhs.begin(), rhs_ = rhs.begin();

    while(lhs_ != lhs.end())
    {
        if(!((*lhs_).first == (*rhs_).first))
            return false;
        else if (!((*lhs_).second == (*rhs_).second))
            return false;

        lhs_++; rhs_++;
    }

    return true;
}
*/

}} // namespace itl boost

#endif // BOOST_ITL_EPISODE_PRODUCT_HPP_HPP_JOFA_011005


